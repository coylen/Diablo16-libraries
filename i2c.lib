//  Library to provide an i2c library of functions for use
//  with a DIABLO16 based intelligent display module from 4D Systems
//
//  Copyright Neil Coyle 2017 Released under the MIT Licence

#constant FALSE, TRUE

//I2C1 functions
func I2C1_IsReady(var addr)
    var status;
    I2C1_Start();
    status := I2C1_Write(addr<<1);
    I2C1_Stop();
    if (status !=1)
        return FALSE;
    else
        return TRUE;
    endif
endfunc

func I2C1_Scan(var devices)
    var addr, status;
    var count := 0;
    for(addr := 0x08; addr < 0x78;  ++addr)
        status := I2C1_IsReady(addr);
        if (status == TRUE)
            count++;
            devices[count] := addr;
        endif
    next
    devices[0] := count;
    return (count);
endfunc

func I2C1_ReadBytes(var addr, var nbytes, var buf)
    var i, ack;
    I2C1_Start();
    ack := I2C1_Write(addr<<1 | 1);
    if (ack !=TRUE)
        I2C1_Stop();
        return FALSE;
    else
        for(i := 0; i < nbytes; i++)
            buf[i] := I2C1_Read();
            if (i != nbytes -1)
                I2C1_Ack();
            endif
        next
        I2C1_Nack();
        I2C1_Stop();
        return TRUE;
    endif
endfunc

func I2C1_WriteBytes(var addr, var nbytes, var buf)
    var i, status;
    I2C1_Start();
    status := I2C1_Write(addr<<1);
    if (status !=1)
        I2C1_Stop();
        return FALSE;
    else
        for(i :=0 ;  i < nbytes; i++)
            status :=  I2C1_Write(buf[i]);
            if (status !=1)
                I2C1_Stop();
                return FALSE;
            endif
        next
        I2C1_Stop();
        return TRUE;
    endif
endfunc

func I2C1_ReadBytesMem(var addr, var memaddr, var nbytes, var buf)
    var i, ack;
    I2C1_Start();
    ack := I2C1_Write(addr<<1);
    if (ack !=TRUE)
        I2C1_Stop();
        return (FALSE);
    endif
    ack := I2C1_Write(memaddr);
    if (ack !=TRUE)
        I2C1_Stop();
        return (FALSE);
    endif
    I2C1_Restart();
    ack := I2C1_Write(addr<<1 | 1);
    if (ack !=TRUE)
        I2C1_Stop();
        return (FALSE);
    endif
    for(i := 0; i < nbytes; i++)
        buf[i] := I2C1_Read();
        if (i != nbytes -1)
            I2C1_Ack();
        endif
    next
    I2C1_Nack();
    I2C1_Stop();
    return TRUE;
endfunc

func I2C1_WriteBytesMem(var addr, var memaddr, var nbytes, var buf)
    var i, ack;
    I2C1_Start();
    ack := I2C1_Write( addr << 1);
    if (ack !=TRUE)
        I2C1_Stop();
        return (FALSE);
    endif
    ack := I2C1_Write(memaddr);
    if (ack !=TRUE)
        I2C1_Stop();
        return (FALSE);
    endif
    for(i := 0; i < nbytes; i++)
        ack := I2C1_Write(buf[i]);
        if (ack !=TRUE)
            I2C1_Stop();
            return (FALSE);
        endif
    next
    I2C1_Stop();
    return (TRUE);
endfunc

func I2C1_ReadWords(var addr, var nwords, var buf)
    var i, ack;
    I2C1_Start();
    ack := I2C1_Write(addr<<1 | 1);
    if (ack !=TRUE)
        I2C1_Stop();
        return FALSE;
    else
        for(i := 0; i < nwords; i++)
       buf[i] := I2C1_Read();
            I2C1_Ack();

            buf[i] := (buf[i] << 8) + I2C1_Read();
            if (i != nwords -1)
                I2C1_Ack();
            endif
        next
        I2C1_Nack();
        I2C1_Stop();
        return TRUE;
    endif
endfunc

func I2C1_WriteWords(var addr, var nwords, var buf)
    var i, status;
    I2C1_Start();
    status := I2C1_Write(addr << 1);
    if (status !=1)
        I2C1_Stop();
        return FALSE;
    else
        for(i :=0 ;  i < nwords; i++)
            status :=  I2C1_Write(HIbyte(buf[i]));
            if (status !=1)
                I2C1_Stop();
                return FALSE;
            endif
            status :=  I2C1_Write(LObyte(buf[i]));
            if (status !=1)
                I2C1_Stop();
                return FALSE;
            endif

        next
        I2C1_Stop();
        return TRUE;
    endif
endfunc

func I2C1_ReadWordsMem(var addr, var memaddr, var nwords, var buf)
    var i, ack;
    I2C1_Start();
    ack := I2C1_Write(addr<<1);
    if (ack !=TRUE)
        I2C1_Stop();
        return (FALSE);
    endif
    ack := I2C1_Write(memaddr);
    if (ack !=TRUE)
        I2C1_Stop();
        return (FALSE);
    endif
    I2C1_Restart();
    ack := I2C1_Write(addr<<1 | 1);
    if (ack !=TRUE)
        I2C1_Stop();
        return (FALSE);
    endif
    for(i := 0; i < nwords; i++)
       buf[i] := I2C1_Read();
            I2C1_Ack();

            buf[i] := (buf[i] << 8) + I2C1_Read();
            if (i != nwords -1)
                I2C1_Ack();
            endif
    next
    I2C1_Nack();
    I2C1_Stop();
    return TRUE;
endfunc

func I2C1_WriteWordsMem(var addr, var memaddr, var nwords, var buf)
    var i, ack, status;
    I2C1_Start();
    ack := I2C1_Write( addr << 1);
    if (ack !=TRUE)
        I2C1_Stop();
        return (FALSE);
    endif
    ack := I2C1_Write(memaddr);
    if (ack !=TRUE)
        I2C1_Stop();
        return (FALSE);
    endif
        for(i :=0 ;  i < nwords; i++)
            status :=  I2C1_Write(HIbyte(buf[i]));
            if (status !=1)
                I2C1_Stop();
                return FALSE;
            endif
            status :=  I2C1_Write(LObyte(buf[i]));
            if (status !=1)
                I2C1_Stop();
                return FALSE;
            endif

        next
    I2C1_Stop();
    return (TRUE);
endfunc

//HACK to see where failing
func I2C1_ReadBytesMem16(var addr, var memaddr, var nbytes, var buf)
    var i, ack;
    I2C1_Start();
    ack := I2C1_Write(addr<<1);
    if (ack !=TRUE)
        I2C1_Stop();
        return 0;// (FALSE);
    endif
    ack := I2C1_Write(HIbyte(memaddr));
    if (ack !=TRUE)
        I2C1_Stop();
        return 1;//(FALSE);
    endif
    ack := I2C1_Write(LObyte(memaddr));
    if (ack !=TRUE)
        I2C1_Stop();
        return 2;//(FALSE);
    endif
    I2C1_Restart();
    ack := I2C1_Write(addr<<1 | 1);
    if (ack !=TRUE)
        I2C1_Stop();
        return 3;//(FALSE);
    endif
    for(i := 0; i < nbytes; i++)
        buf[i] := I2C1_Read();
        if (i != nbytes -1)
            I2C1_Ack();
        endif
    next
    I2C1_Nack();
    I2C1_Stop();
    return 4;//TRUE;
endfunc

func I2C1_WriteBytesMem16(var addr, var memaddr, var nbytes, var buf)
    var i, ack;
    I2C1_Start();
    ack := I2C1_Write( addr << 1);
    if (ack !=TRUE)
        I2C1_Stop();
        return (FALSE);
    endif
    ack := I2C1_Write(HIbyte(memaddr));
    if (ack !=TRUE)
        I2C1_Stop();
        return (FALSE);
    endif
    ack := I2C1_Write(LObyte(memaddr));
    if (ack !=TRUE)
        I2C1_Stop();
        return (FALSE);
    endif
    for(i := 0; i < nbytes; i++)
        ack := I2C1_Write(buf[i]);
        if (ack !=TRUE)
            I2C1_Stop();
            return (FALSE);
        endif
    next
    I2C1_Stop();
    return (TRUE);
endfunc

func I2C1_ReadWordsMem16(var addr, var memaddr, var nwords, var buf)
    var i, ack;
    I2C1_Start();
    ack := I2C1_Write(addr<<1);
    if (ack !=TRUE)
        I2C1_Stop();
        return (FALSE);
    endif
    ack := I2C1_Write(HIbyte(memaddr));
    if (ack !=TRUE)
        I2C1_Stop();
        return (FALSE);
    endif
    ack := I2C1_Write(LObyte(memaddr));
    if (ack !=TRUE)
        I2C1_Stop();
        return (FALSE);
    endif
	I2C1_Restart();
    ack := I2C1_Write(addr<<1 | 1);
    if (ack !=TRUE)
        I2C1_Stop();
        return (FALSE);
    endif
	for(i := 0; i < nwords; i++)
       buf[i] := I2C1_Read();
            I2C1_Ack();

            buf[i] := (buf[i] << 8) + I2C1_Read();
            if (i != nwords -1)
                I2C1_Ack();
            endif
		print("word : ",i," is ",buf[i],"\n");
	next
    I2C1_Nack();
    I2C1_Stop();
    return 1;//TRUE;
endfunc

func I2C1_WriteWordsMem16(var addr, var memaddr, var nwords, var buf)
    var i, ack, status;
    I2C1_Start();
    ack := I2C1_Write( addr << 1);
	print("ACK: ",ack, "\n");
    if (ack !=TRUE)
        I2C1_Stop();
        return (FALSE);
    endif
    ack := I2C1_Write(HIbyte(memaddr));
    if (ack !=TRUE)
        I2C1_Stop();
        return (FALSE);
    endif
    ack := I2C1_Write(LObyte(memaddr));
    if (ack !=TRUE)
        I2C1_Stop();
        return (FALSE);
    endif
        for(i :=0 ;  i < nwords; i++)
            status :=  I2C1_Write(HIbyte(buf[i]));
            if (status !=1)
                I2C1_Stop();
                return FALSE;
            endif
            status :=  I2C1_Write(LObyte(buf[i]));
            if (status !=1)
                I2C1_Stop();
                return FALSE;
            endif
		print("word : ",i," is ",buf[i],"\n");
        next
    I2C1_Stop();
    return (TRUE);
endfunc



//I2C2 functions
func I2C2_IsReady(var addr)
    var status;
    I2C2_Start();
    status := I2C2_Write(addr<<1);
    I2C2_Stop();
    if (status !=1)
        return FALSE;
    else
        return TRUE;
    endif
endfunc

func I2C2_Scan(var devices)
    var addr, status;
    var count := 0;
    for (addr := 0x08; addr < 0x78;  ++addr)
        status := I2C2_IsReady(addr);
        if (status == TRUE)
            count++;
            devices[count] := addr;
        endif
    next
    devices[0] := count;
    return (devices);
endfunc

func I2C2_ReadBytes(var addr, var nbytes, var buf)
    var i, ack;
    I2C2_Start();
    ack := I2C2_Write(addr<<1 | 1);
    if (ack !=TRUE)
        I2C2_Stop();
        return FALSE;
    else
        for(i := 0; i < nbytes; i++)
            buf[i] := I2C2_Read();
            if (i != nbytes -1)
                I2C2_Ack();
            endif
        next
        I2C2_Nack();
        I2C2_Stop();
        return TRUE;
    endif
endfunc

func I2C2_WriteBytes(var addr, var nbytes, var buf)
    var i, status;
    I2C2_Start();
    status := I2C2_Write(addr<<1);
    if (status !=1)
        I2C2_Stop();
        return FALSE;
    else
        for(i :=0 ;  i < nbytes; i++)
            status :=  I2C2_Write(buf[i]);
            if (status !=1)
                I2C2_Stop();
                return FALSE;
            endif
        next
        I2C2_Stop();
        return TRUE;
    endif
endfunc

func I2C2_ReadBytesMem(var addr, var memaddr, var nbytes, var buf)
    var i, ack;
    I2C2_Start();
    ack := I2C2_Write(addr<<1);
    if (ack !=TRUE)
        I2C2_Stop();
        return (FALSE);
    endif
    ack := I2C2_Write(memaddr);
    if (ack !=TRUE)
        I2C2_Stop();
        return (FALSE);
    endif
    I2C2_Restart();
    ack := I2C2_Write(addr<<1 | 1);
    if (ack !=TRUE)
        I2C2_Stop();
        return (FALSE);
    endif
    for(i := 0; i < nbytes; i++)
        buf[i] := I2C2_Read();
        if (i != nbytes -1)
            I2C2_Ack();
        endif
    next
    I2C2_Nack();
    I2C2_Stop();
    return TRUE;
endfunc

func I2C2_WriteBytesMem(var addr, var memaddr, var nbytes, var buf)
    var i, ack;
    I2C2_Start();
    ack := I2C2_Write( addr << 1);
    if (ack !=TRUE)
        I2C2_Stop();
        return (FALSE);
    endif
    ack := I2C2_Write(memaddr);
    if (ack !=TRUE)
        I2C2_Stop();
        return (FALSE);
    endif
    for(i := 0; i < nbytes; i++)
        ack := I2C2_Write(buf[i]);
        if (ack !=TRUE)
            I2C2_Stop();
            return (FALSE);
        endif
    next
    I2C2_Stop();
    return (TRUE);
endfunc

func I2C2_ReadWords(var addr, var nwords, var buf)
    var i, ack;
    I2C2_Start();
    ack := I2C2_Write(addr<<1 | 1);
    if (ack !=TRUE)
        I2C2_Stop();
        return FALSE;
    else
        for(i := 0; i < nwords; i++)
       buf[i] := I2C2_Read();
            I2C2_Ack();

            buf[i] := (buf[i] << 8) + I2C2_Read();
            if (i != nwords -1)
                I2C2_Ack();
            endif
        next
        I2C2_Nack();
        I2C2_Stop();
        return TRUE;
    endif
endfunc

func I2C2_WriteWords(var addr, var nwords, var buf)
    var i, status;
    I2C2_Start();
    status := I2C2_Write(addr << 1);
    if (status !=1)
        I2C2_Stop();
        return FALSE;
    else
        for(i :=0 ;  i < nwords; i++)
            status :=  I2C2_Write(HIbyte(buf[i]));
            if (status !=1)
                I2C2_Stop();
                return FALSE;
            endif
            status :=  I2C2_Write(LObyte(buf[i]));
            if (status !=1)
                I2C2_Stop();
                return FALSE;
            endif

        next
        I2C2_Stop();
        return TRUE;
    endif
endfunc

func I2C2_ReadWordsMem(var addr, var memaddr, var nwords, var buf)
    var i, ack;
    I2C2_Start();
    ack := I2C2_Write(addr<<1);
    if (ack !=TRUE)
        I2C2_Stop();
        return (FALSE);
    endif
    ack := I2C2_Write(memaddr);
    if (ack !=TRUE)
        I2C2_Stop();
        return (FALSE);
    endif
    I2C2_Restart();
    ack := I2C2_Write(addr<<1 | 1);
    if (ack !=TRUE)
        I2C2_Stop();
        return (FALSE);
    endif
    for(i := 0; i < nwords; i++)
       buf[i] := I2C2_Read();
            I2C2_Ack();

            buf[i] := (buf[i] << 8) + I2C2_Read();
            if (i != nwords -1)
                I2C2_Ack();
            endif
    next
    I2C2_Nack();
    I2C2_Stop();
    return TRUE;
endfunc

func I2C2_WriteWordsMem(var addr, var memaddr, var nwords, var buf)
    var i, ack, status;
    I2C2_Start();
    ack := I2C2_Write( addr << 1);
    if (ack !=TRUE)
        I2C2_Stop();
        return (FALSE);
    endif
    ack := I2C2_Write(memaddr);
    if (ack !=TRUE)
        I2C2_Stop();
        return (FALSE);
    endif
        for(i :=0 ;  i < nwords; i++)
            status :=  I2C2_Write(HIbyte(buf[i]));
            if (status !=1)
                I2C2_Stop();
                return FALSE;
            endif
            status :=  I2C2_Write(LObyte(buf[i]));
            if (status !=1)
                I2C2_Stop();
                return FALSE;
            endif

        next
    I2C2_Stop();
    return (TRUE);
endfunc

func I2C2_ReadBytesMem16(var addr, var memaddr, var nbytes, var buf)
    var i, ack;
    I2C2_Start();
    ack := I2C2_Write(addr<<1);
    if (ack !=TRUE)
        I2C2_Stop();
        return (FALSE);
    endif
    ack := I2C2_Write(HIbyte(memaddr));
    if (ack !=TRUE)
        I2C2_Stop();
        return (FALSE);
    endif
    ack := I2C2_Write(LObyte(memaddr));
    if (ack !=TRUE)
        I2C2_Stop();
        return (FALSE);
    endif
    I2C2_Restart();
    ack := I2C2_Write(addr<<1 | 1);
    if (ack !=TRUE)
        I2C2_Stop();
        return (FALSE);
    endif
    for(i := 0; i < nbytes; i++)
        buf[i] := I2C2_Read();
        if (i != nbytes -1)
            I2C2_Ack();
        endif
    next
    I2C2_Nack();
    I2C2_Stop();
    return TRUE;
endfunc

func I2C2_WriteBytesMem16(var addr, var memaddr, var nbytes, var buf)
    var i, ack;
    I2C2_Start();
    ack := I2C2_Write( addr << 1);
    if (ack !=TRUE)
        I2C2_Stop();
        return (FALSE);
    endif
    ack := I2C2_Write(HIbyte(memaddr));
    if (ack !=TRUE)
        I2C2_Stop();
        return (FALSE);
    endif
    ack := I2C2_Write(LObyte(memaddr));
    if (ack !=TRUE)
        I2C2_Stop();
        return (FALSE);
    endif
    for(i := 0; i < nbytes; i++)
        ack := I2C2_Write(buf[i]);
        if (ack !=TRUE)
            I2C2_Stop();
            return (FALSE);
        endif
    next
    I2C2_Stop();
    return (TRUE);
endfunc

func I2C2_ReadWordsMem16(var addr, var memaddr, var nwords, var buf)
    var i, ack;
    I2C2_Start();
    ack := I2C2_Write(addr<<1);
    if (ack !=TRUE)
        I2C2_Stop();
        return (FALSE);
    endif
    ack := I2C2_Write(HIbyte(memaddr));
    if (ack !=TRUE)
        I2C2_Stop();
        return (FALSE);
    endif
    ack := I2C2_Write(LObyte(memaddr));
    if (ack !=TRUE)
        I2C2_Stop();
        return (FALSE);
    endif
    I2C2_Restart();
    ack := I2C2_Write(addr<<1 | 1);
    if (ack !=TRUE)
        I2C2_Stop();
        return (FALSE);
    endif
    for(i := 0; i < nwords; i++)
       buf[i] := I2C2_Read();
            I2C2_Ack();

            buf[i] := (buf[i] << 8) + I2C2_Read();
            if (i != nwords -1)
                I2C2_Ack();
            endif
    next
    I2C2_Nack();
    I2C2_Stop();
    return TRUE;
endfunc

func I2C2_WriteWordsMem16(var addr, var memaddr, var nwords, var buf)
    var i, ack, status;
    I2C2_Start();
    ack := I2C2_Write( addr << 1);
    if (ack !=TRUE)
        I2C2_Stop();
        return (FALSE);
    endif
    ack := I2C2_Write(HIbyte(memaddr));
    if (ack !=TRUE)
        I2C2_Stop();
        return (FALSE);
    endif
    ack := I2C2_Write(LObyte(memaddr));
    if (ack !=TRUE)
        I2C2_Stop();
        return (FALSE);
    endif
        for(i :=0 ;  i < nwords; i++)
            status :=  I2C2_Write(HIbyte(buf[i]));
            if (status !=1)
                I2C2_Stop();
                return FALSE;
            endif
            status :=  I2C2_Write(LObyte(buf[i]));
            if (status !=1)
                I2C2_Stop();
                return FALSE;
            endif

        next
    I2C2_Stop();
    return (TRUE);
endfunc


//I2C3 functions
func I2C3_IsReady(var addr)
    var status;
    I2C3_Start();
    status := I2C3_Write(addr<<1);
    I2C3_Stop();
    if (status !=1 )
        return FALSE;
    else:
        return TRUE;
    endif
endfunc

func I2C3_Scan(var devices)
    var addr, status;
    var count := 0;
    for (addr := 0x08; addr < 0x78;  ++addr)
        status := I2C3_IsReady(addr);
        if (status == TRUE)
            count++;
            devices[count] := addr;
        endif
    next
    devices[0] := count;
    return (devices);
endfunc

func I2C3_ReadBytes(var addr, var nbytes, var buf)
    var i, ack;
    I2C3_Start();
    ack := I2C3_Write(addr<<1 | 1);
    if (ack !=TRUE)
        I2C3_Stop();
        return FALSE;
    else
        for(i := 0; i < nbytes; i++)
            buf[i] := I2C3_Read();
            if (i != nbytes -1)
                I2C3_Ack();
            endif
        next
        I2C3_Nack();
        I2C3_Stop();
        return TRUE;
    endif
endfunc

func I2C3_WriteBytes(var addr, var nbytes, var buf)
    var i, status;
    I2C3_Start();
    status := I2C3_Write(addr<<1);
    if (status !=1)
        I2C3_Stop();
        return FALSE;
    else
        for(i := 0 ;  i < nbytes; i++)
            status :=  I2C3_Write(buf[i]);
            if (status !=1)
                I2C3_Stop();
                return FALSE;
            endif
        next
        I2C3_Stop();
        return TRUE;
    endif
endfunc

func I2C3_ReadBytesMem(var addr, var memaddr, var nbytes, var buf)
    var i, ack;
    I2C3_Start();
    ack := I2C3_Write(addr<<1);
    if (ack !=TRUE)
        I2C3_Stop();
        return (FALSE);
    endif
    ack := I2C3_Write(memaddr);
    if (ack !=TRUE)
        I2C3_Stop();
        return (FALSE);
    endif
    I2C3_Restart();
    ack := I2C3_Write(addr<<1 | 1);
    if (ack !=TRUE)
        I2C3_Stop();
        return (FALSE);
    endif
    for(i := 0; i < nbytes; i++)
        buf[i] := I2C3_Read();
        if (i != nbytes -1)
            I2C3_Ack();
        endif
    next
    I2C3_Nack();
    I2C3_Stop();
    return TRUE;
endfunc

func I2C3_WriteBytesMem(var addr, var memaddr, var nbytes, var buf)
    var i, ack;
    I2C3_Start();
    ack := I2C3_Write( addr << 1);
    if (ack !=TRUE)
        I2C3_Stop();
        return (FALSE);
    endif
    ack := I2C3_Write(memaddr);
    if (ack !=TRUE)
        I2C3_Stop();
        return (FALSE);
    endif
    for(i := 0; i < nbytes; i++)
        ack := I2C3_Write(buf[i]);
        if (ack !=TRUE)
            I2C3_Stop();
            return (FALSE);
        endif
    next
    I2C3_Stop();
    return (TRUE);
endfunc

func I2C3_ReadWords(var addr, var nwords, var buf)
    var i, ack;
    I2C3_Start();
    ack := I2C3_Write(addr<<1 | 1);
    if (ack !=TRUE)
        I2C3_Stop();
        return FALSE;
    else
        for(i := 0; i < nwords; i++)
       buf[i] := I2C3_Read();
            I2C3_Ack();

            buf[i] := (buf[i] << 8) + I2C3_Read();
            if (i != nwords -1)
                I2C3_Ack();
            endif
        next
        I2C3_Nack();
        I2C3_Stop();
        return TRUE;
    endif
endfunc

func I2C3_WriteWords(var addr, var nwords, var buf)
    var i, status;
    I2C3_Start();
    status := I2C3_Write(addr << 1);
    if (status !=1)
        I2C3_Stop();
        return FALSE;
    else
        for(i :=0 ;  i < nwords; i++)
            status :=  I2C3_Write(HIbyte(buf[i]));
            if (status !=1)
                I2C3_Stop();
                return FALSE;
            endif
            status :=  I2C3_Write(LObyte(buf[i]));
            if (status !=1)
                I2C3_Stop();
                return FALSE;
            endif

        next
        I2C3_Stop();
        return TRUE;
    endif
endfunc

func I2C3_ReadWordsMem(var addr, var memaddr, var nwords, var buf)
    var i, ack;
    I2C3_Start();
    ack := I2C3_Write(addr<<1);
    if (ack !=TRUE)
        I2C3_Stop();
        return (FALSE);
    endif
    ack := I2C3_Write(memaddr);
    if (ack !=TRUE)
        I2C3_Stop();
        return (FALSE);
    endif
    I2C3_Restart();
    ack := I2C3_Write(addr<<1 | 1);
    if (ack !=TRUE)
        I2C3_Stop();
        return (FALSE);
    endif
    for(i := 0; i < nwords; i++)
       buf[i] := I2C3_Read();
            I2C3_Ack();

            buf[i] := (buf[i] << 8) + I2C3_Read();
            if (i != nwords -1)
                I2C3_Ack();
            endif
    next
    I2C3_Nack();
    I2C3_Stop();
    return TRUE;
endfunc

func I2C3_WriteWordsMem(var addr, var memaddr, var nwords, var buf)
    var i, ack, status;
    I2C3_Start();
    ack := I2C3_Write( addr << 1);
    if (ack !=TRUE)
        I2C3_Stop();
        return (FALSE);
    endif
    ack := I2C3_Write(memaddr);
    if (ack !=TRUE)
        I2C3_Stop();
        return (FALSE);
    endif
        for(i :=0 ;  i < nwords; i++)
            status :=  I2C3_Write(HIbyte(buf[i]));
            if (status !=1)
                I2C3_Stop();
                return FALSE;
            endif
            status :=  I2C3_Write(LObyte(buf[i]));
            if (status !=1)
                I2C3_Stop();
                return FALSE;
            endif

        next
    I2C3_Stop();
    return (TRUE);
endfunc

func I2C3_ReadBytesMem16(var addr, var memaddr, var nbytes, var buf)
    var i, ack;
    I2C3_Start();
    ack := I2C3_Write(addr<<1);
    if (ack !=TRUE)
        I2C3_Stop();
        return (FALSE);
    endif
    ack := I2C3_Write(HIbyte(memaddr));
    if (ack !=TRUE)
        I2C3_Stop();
        return (FALSE);
    endif
    ack := I2C3_Write(LObyte(memaddr));
    if (ack !=TRUE)
        I2C3_Stop();
        return (FALSE);
    endif
    I2C3_Restart();
    ack := I2C3_Write(addr<<1 | 1);
    if (ack !=TRUE)
        I2C3_Stop();
        return (FALSE);
    endif
    for(i := 0; i < nbytes; i++)
        buf[i] := I2C3_Read();
        if (i != nbytes -1)
            I2C3_Ack();
        endif
    next
    I2C3_Nack();
    I2C3_Stop();
    return TRUE;
endfunc

func I2C3_WriteBytesMem16(var addr, var memaddr, var nbytes, var buf)
    var i, ack;
    I2C3_Start();
    ack := I2C3_Write( addr << 1);
    if (ack !=TRUE)
        I2C3_Stop();
        return (FALSE);
    endif
    ack := I2C3_Write(HIbyte(memaddr));
    if (ack !=TRUE)
        I2C3_Stop();
        return (FALSE);
    endif
    ack := I2C3_Write(LObyte(memaddr));
    if (ack !=TRUE)
        I2C3_Stop();
        return (FALSE);
    endif
    for(i := 0; i < nbytes; i++)
        ack := I2C3_Write(buf[i]);
        if (ack !=TRUE)
            I2C3_Stop();
            return (FALSE);
        endif
    next
    I2C3_Stop();
    return (TRUE);
endfunc

func I2C3_ReadWordsMem16(var addr, var memaddr, var nwords, var buf)
    var i, ack;
    I2C3_Start();
    ack := I2C3_Write(addr<<1);
    if (ack !=TRUE)
        I2C3_Stop();
        return (FALSE);
    endif
    ack := I2C3_Write(HIbyte(memaddr));
    if (ack !=TRUE)
        I2C3_Stop();
        return (FALSE);
    endif
    ack := I2C3_Write(LObyte(memaddr));
    if (ack !=TRUE)
        I2C3_Stop();
        return (FALSE);
    endif
    I2C3_Restart();
    ack := I2C3_Write(addr<<1 | 1);
    if (ack !=TRUE)
        I2C3_Stop();
        return (FALSE);
    endif
    for(i := 0; i < nwords; i++)
       buf[i] := I2C3_Read();
            I2C3_Ack();

            buf[i] := (buf[i] << 8) + I2C3_Read();
            if (i != nwords -1)
                I2C3_Ack();
            endif
    next
    I2C3_Nack();
    I2C3_Stop();
    return TRUE;
endfunc

func I2C3_WriteWordsMem16(var addr, var memaddr, var nwords, var buf)
    var i, ack, status;
    I2C3_Start();
    ack := I2C3_Write( addr << 1);
    if (ack !=TRUE)
        I2C3_Stop();
        return (FALSE);
    endif
    ack := I2C3_Write(HIbyte(memaddr));
    if (ack !=TRUE)
        I2C3_Stop();
        return (FALSE);
    endif
    ack := I2C3_Write(LObyte(memaddr));
    if (ack !=TRUE)
        I2C3_Stop();
        return (FALSE);
    endif
        for(i :=0 ;  i < nwords; i++)
            status :=  I2C3_Write(HIbyte(buf[i]));
            if (status !=1)
                I2C3_Stop();
                return FALSE;
            endif
            status :=  I2C3_Write(LObyte(buf[i]));
            if (status !=1)
                I2C3_Stop();
                return FALSE;
            endif

        next
    I2C3_Stop();
    return (TRUE);
endfunc


//HELPER FUNCTIONS TO ALLOW I2C BUS NO AS A PARAMETER
func I2C_IsReady(var i2c, var addr)
    switch (i2c)
        case 1:
            return I2C1_IsReady(addr);
            break;
        case 2:
            return I2C1_IsReady(addr);
            break;
        case 3:
            return I2C1_IsReady(addr);
            break;
    endswitch
	return FALSE;
endfunc

func I2C_Scan(var i2c, var devices)
     switch (i2c)
        case 1:
            return I2C1_Scan(devices);
            break;
        case 2:
            return I2C2_Scan(devices);
            break;
        case 3:
            return I2C3_Scan(devices);
            break;
    endswitch
	return 0;
endfunc

func I2C_ReadBytes(var i2c, var addr, var nbytes, var buf)
     switch (i2c)
        case 1:
            return I2C1_ReadBytes(addr, nbytes, buf);
            break;
        case 2:
            return I2C2_ReadBytes(addr, nbytes, buf);
            break;
        case 3:
            return I2C3_ReadBytes(addr, nbytes, buf);
            break;
    endswitch
endfunc

func I2C_WriteBytes(var i2c, var addr, var nbytes, var buf)
     switch (i2c)
        case 1:
            return I2C1_WriteBytes(addr, nbytes, buf);
            break;
        case 2:
            return I2C2_WriteBytes(addr, nbytes, buf);
            break;
        case 3:
            return I2C3_WriteBytes(addr, nbytes, buf);
            break;
    endswitch
endfunc

func I2C_ReadBytesMem(var i2c, var addr, var memaddr, var nbytes, var buf)
     switch (i2c)
        case 1:
            return I2C1_ReadBytesMem(addr, memaddr, nbytes, buf);
            break;
        case 2:
            return I2C2_ReadBytesMem(addr, memaddr, nbytes, buf);
            break;
        case 3:
            return I2C3_ReadBytesMem(addr, memaddr, nbytes, buf);
            break;
    endswitch
    return 0;
endfunc

func I2C_WriteBytesMem(var i2c, var addr, var memaddr, var nbytes, var buf)
     switch (i2c)
        case 1:
            return I2C1_WriteBytesMem(addr, memaddr, nbytes, buf);
            break;
        case 2:
            return I2C2_WriteBytesMem(addr, memaddr, nbytes, buf);
            break;
        case 3:
            return I2C3_WriteBytesMem(addr, memaddr, nbytes, buf);
            break;
    endswitch
    return 0;
endfunc

func I2C_ReadWords(var i2c, var addr, var nwords, var buf)
     switch (i2c)
        case 1:
            return I2C1_ReadWords(addr, nwords, buf);
            break;
        case 2:
            return I2C2_ReadWords(addr, nwords, buf);
            break;
        case 3:
            return I2C3_ReadWords(addr, nwords, buf);
            break;
    endswitch
endfunc

func I2C_WriteWords(var i2c, var addr, var nwords, var buf)
     switch (i2c)
        case 1:
            return I2C1_WriteWords(addr, nwords, buf);
            break;
        case 2:
            return I2C2_WriteWords(addr, nwords, buf);
            break;
        case 3:
            return I2C3_WriteWords(addr, nwords, buf);
            break;
    endswitch
endfunc

func I2C_ReadWordsMem(var i2c, var addr, var memaddr, var nwords, var buf)
     switch (i2c)
        case 1:
            return I2C1_ReadWordsMem(addr, memaddr, nwords, buf);
            break;
        case 2:
            return I2C2_ReadWordsMem (addr, memaddr, nwords, buf);
            break;
        case 3:
            return I2C3_ReadWordsMem(addr, memaddr, nwords, buf);
            break;
    endswitch
    return 0;
endfunc

func I2C_WriteWordsMem(var i2c, var addr, var memaddr, var nwords, var buf)
     switch (i2c)
        case 1:
            return I2C1_WriteWordsMem(addr, memaddr, nwords, buf);
            break;
        case 2:
            return I2C2_WriteWordsMem(addr, memaddr, nwords, buf);
            break;
        case 3:
            return I2C3_WriteWordsMem(addr, memaddr, nwords, buf);
            break;
    endswitch
    return 0;
endfunc

func I2C_ReadBytesMem16(var i2c, var addr, var memaddr, var nbytes, var buf)
     switch (i2c)
        case 1:
            return I2C1_ReadBytesMem16(addr, memaddr, nbytes, buf);
            break;
        case 2:
            return I2C2_ReadBytesMem16(addr, memaddr, nbytes, buf);
            break;
        case 3:
            return I2C3_ReadBytesMem16(addr, memaddr, nbytes, buf);
            break;
    endswitch
    return 0;
endfunc

func I2C_WriteBytesMem16(var i2c, var addr, var memaddr, var nbytes, var buf)
     switch (i2c)
        case 1:
            return I2C1_WriteBytesMem16(addr, memaddr, nbytes, buf);
            break;
        case 2:
            return I2C2_WriteBytesMem16(addr, memaddr, nbytes, buf);
            break;
        case 3:
            return I2C3_WriteBytesMem16(addr, memaddr, nbytes, buf);
            break;
    endswitch
    return 0;
endfunc

func I2C_ReadWordsMem16(var i2c, var addr, var memaddr, var nwords, var buf)
     switch (i2c)
        case 1:
            return I2C1_ReadWordsMem16(addr, memaddr, nwords, buf);
			break;
        case 2:
            return I2C2_ReadWordsMem16(addr, memaddr, nwords, buf);
            break;
        case 3:
            return I2C3_ReadWordsMem16(addr, memaddr, nwords, buf);
            break;
    endswitch
    return 0;
endfunc

func I2C_WriteWordsMem16(var i2c, var addr, var memaddr, var nwords, var buf)
     switch (i2c)
        case 1:
            return I2C1_WriteWordsMem16(addr, memaddr, nwords, buf);
            break;
        case 2:
            return I2C2_WriteWordsMem16(addr, memaddr, nwords, buf);
            break;
        case 3:
            return I2C3_WriteWordsMem16(addr, memaddr, nwords, buf);
            break;
    endswitch
    return 0; 
endfunc

