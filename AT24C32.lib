//  Library to support the use of AT24C32 EEPROM expansion boards
//  With a DIABLO16 based intelligent display module from 4D Systems
//  This library is dependant on my i2c function library
//
//  Copyright Neil Coyle 2017 Released under the MIT Licence

#inherit "..\\libs\\i2c.lib"

#constant AT24C32_Address        0x50
var AT24C32_i2c := 1;

//AT24C32 functions
//TODO: WRITE BYTES TO BE UPDATED
func AT24C32_WriteBytes(var offset, var nbytes, var *ptr_buf)
    var ack,endp, position, bytes_on_page, pages, overrun;
    endp := AT24C32_CheckWriteOffset(offset, nbytes);
    if(endp == 0)
        return -1;
    endif
		if(endp < 0)
		overrun := 1;
		endp *= -1;
	endif
	
	bytes_on_page := MIN(LObyte(endp), nbytes);
	pages := HIbyte(endp);
	position := bytes_on_page;
	wait_on_I2C();
	ack := I2C_WriteBytesMem16(AT24C32_i2c, AT24C32_Address, offset, position, ptr_buf);
	offset += bytes_on_page;
	if(pages > 0)
		for(endp := 0; endp < pages; endp++)
			if (offset > 0xFFF)
				offset := 0;
			endif
			wait_on_I2C();
			ack := I2C_WriteBytesMem16(AT24C32_i2c, AT24C32_Address, offset , 32, &ptr_buf[position]);
			position += 32;
			offset += 32;
		next
	endif
	if (position < nwords)
			wait_on_I2C();
			ack := I2C_WriteBytesMem16(AT24C32_i2c, AT24C32_Address, offset , nbytes - position, &ptr_buf[position]);
	endif
	return ack;	
	
endfunc

func AT24C32_WriteWords(var offset, var nwords, var *ptr_buf)
    var ack, endp, position, bytes_on_page, pages, overrun;
    endp := AT24C32_CheckWriteOffset(offset, nwords * 2);
    if(endp == 0)
        return -1;
    endif
	if(endp < 0)
		overrun := 1;
		endp *= -1;
	endif

	bytes_on_page := MIN(LObyte(endp), nwords * 2);
	pages := HIbyte(endp);
	position := bytes_on_page / 2;
	wait_on_I2C();
	ack := I2C_WriteWordsMem16(AT24C32_i2c, AT24C32_Address, offset, position, ptr_buf);
	offset += bytes_on_page;
	if(pages > 0)
		for(endp := 0; endp < pages; endp++)
			if (offset > 0xFFF)
				offset := 0;
			endif
			wait_on_I2C();
			ack := I2C_WriteWordsMem16(AT24C32_i2c, AT24C32_Address, offset , 16, &ptr_buf[position]);
			position += 16;
			offset += 32;
		next
	endif
	if (position < nwords)
			wait_on_I2C();
			ack := I2C_WriteWordsMem16(AT24C32_i2c, AT24C32_Address, offset , nwords - position, &ptr_buf[position]);
	endif
	return ack;
			
endfunc

func AT24C32_ReadBytes(var offset, var nbytes, var *ptr_buf)
    if (AT24C32_CheckReadOffset(offset, nbytes) == -1)
        return -1;
    endif
    var ack;
    ack := I2C_ReadBytesMem16(AT24C32_i2c, AT24C32_Address, offset, nbytes, ptr_buf);
    return ack;
endfunc

func AT24C32_ReadWords(var offset, var nwords, var *ptr_buf)
    if (AT24C32_CheckReadOffset(offset, nwords * 2) == -1)
        return -1;
    endif
	var ack;
	wait_on_I2C();
    ack := I2C_ReadWordsMem16(AT24C32_i2c, AT24C32_Address, offset, nwords, ptr_buf);
	return ack;
endfunc


//return encoded write offset
//lowbyte is bytes_on the first pages
//Hibyte is the number of complete pages
//if there is a last page overrun then the 
//whole object is set negative by -1 multiplication
func AT24C32_CheckWriteOffset(var offset, var nbytes)
    if (offset >= 0 && offset <=0xFFF)
        var bytes_on_page, pages;
        bytes_on_page := 32 - (offset & 0x001F);
		pages := (nbytes - bytes_on_page) / 32;
		if (pages < 0)
			pages := 0;
		endif
		pages := pages << 8 + bytes_on_page;
		if (offset + nbytes > 0xFFF)
			pages *= -1;
		endif
		return pages;
	else
		return 0;
    endif
endfunc

func AT24C32_CheckReadOffset(var offset, var nbytes)
    if (offset >= 0 && offset + nbytes <=0xFFF)
        return 0;
    else
        return -1;
    endif
endfunc

func wait_on_I2C()
	repeat
	until(I2C_IsReady(AT24C32_i2c, AT24C32_Address));
endfunc



